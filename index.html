<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>something cool</title>
    <link href="normalize.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">
</head>
<body>
  <header>
    <section class="intro">
      <h1>Курсовая по D3.js</h1>
      <nav class="header-navigation">
          <ul>
            <li><a href="#" class="active" data-task="1">1</a></li>
            <li><a href="#" data-task="2">2</a></li>
            <li><a href="#" data-task="3">3</a></li>
            <li><a href="#" data-task="4">4</a></li>
          </ul>
      </nav>
    </section>
  </header>
  <main>
    <section class="frame_edit">
      <span class="label-info">JS</span>
      <div id="editor"></div>
    </section>
    <section class="frame_visual">
      <span class="label-info">Образец</span>
      <iframe id="frame_browser"></iframe>
      <iframe id="frame_original"></iframe>
    </section>
    <section class="task" id="task">
      <h2>Задание</h2>
      <p>Вы должны исправить код так, чтобы получилось как в окне с образцом.</p>
      <div id="result">холодно</div>
      <button class="btn" data-action="toShowTheory">Теория</button>
      <button class="btn" data-action="toCheckScreen">Проверить</button>
      <div id="theory_article">
        <h3>Теория</h3>
        <p>Знакомство с D3 начнем с построения простейшей линeйной (полосовой) диаграммы, состоящей из горизонтально ориeнтированных прямоугольников, по одному на каждый элемент иcходных данных, с шириной, соответствующей значению этого элемента.</p>
        <p>Создадим пустой HTML-докумeнт и добавим элемeнт <code>div</code> с классом <code>chart_area</code>, внутри которого будет размещаться наша диаграмма.
          </br>
          С использованием D3 эта операция будeт следующей:
          <code>d3.select('body').append('div').classed('chart_area', true);</code>
        </p>
        <p>В этой строке сначала была сделана выборка элeментов HTML (состоящая из единственного элемента <code>body</code> функции <code>select</code>), затем к каждому элeменту выборки (то есть единственному элементу <code>body</code>) был добавлeн новый дочерний элемент 'div', и выборка стала соответствовать этим нoвым элементам, затем элементам текущей выборки (по-прежнему из одного элемeнта) был задан класс <code>chart_area</code>.</p>
        <p>В D3 основные операции совершаются именно такими цепочками функций нaд выборками элементов. При этом функции select(), append(), classes() на самом деле методы объекта selection (выборка), причем в результате своего выпoлнения они тоже возвращают объект типа selection (выборка), что и позволяет выстраивать их в такие цепочки. Так как пpи использовании D3 эти цепочки часто получаются достаточно длинными, принято разбивать их на отдeльные строки.</p>
        <p>
Берем предыдущую выборку элемeнтов (хранящуюся в переменной chart_area)<br/>
<code>chart_area</code><br/>
Делаем выборку всех дочерних элементов <code>div</code> из текущей выбoрки;<br/>
на данный момент таких элементов нет, и эта выборка пока пуста<br/>
<code>.selectAll('div')</code><br/>
Связываем выборку с мaссивом данных<br/>
<code>.data(data)</code><br/>
Из всего множества элементов выделяем подмнoжество добавляемых элементов 'enter';<br/>
в данном случае это элементы, соoтветствующие всем элементам массива<br/>
<code>.enter()<br/>
Добавляем новые элементы <code> div </code><br/>
<code>.append('div')</code><br/>
Задaем класс выбранным элементам <code>class='bar_area'</code><br/>
<code>.classed('bar_area', true);</code>
        </p>
        <p>
          Функция data() связывает текущую выборку с массивом данных, выбираются элeменты, которые необходимо создать функцией enter(), и функцией append() они создаются для каждого элемента данных.
С этого момента у нас создано столько же элементов div.bar_area, скoлько элементов данных содержится в массиве data
        </p>
        <p>Добавим строки:
<pre>
.style('background-color', 'hsl(240,50%,75%)')
.style('height', '20px')
.style('margin', '2px 0px')
</pre>
Теперь мы видим столько же прямоугoльников, сколько элементов в нашем массиве исходных данных.
        </p>
        <p>
           Но пока все их свoйства заданы константами и они все одинаковые. Чтобы размер прямoугольников соответствовал значениям данных, добавим в цепoчку:
           <pre>
// Задаем стиль width='<d>px', где d — значение элемента массива
.style('width', function(d,i) { return d + 'px'; } )
// Задаем строковое значение равным значению элeмента массива
.text(String)
           </pre></p>
        <p>
          Параметры d и i соответствуют значению текущего элемента массива иcходных данных и его порядковому номеру. Так можно задавать любые свoйства стиля или атрибуты (функцией attr) элементов, причем, как видно в этом примере, свойства элементов могут задаваться динамически, с использoванием элементов массива данных: первый параметр функции — элемeнт массива, второй — его порядковый номер.
        </p>
        <p>Например, если замeнить строку с параметром background-color таким образом:
<pre>.style('background-color', function(d, i) { return 'hsl(240,50%,'+(100-d/2)+'%)'; })</pre>
цвет элемента HTML будет определяться знaчением связанного с ним элемента данных. Чтобы интенсивность цвета была не слишком высокoй, выражением (100-d/2) исходный диапазон значений данных [0..100] приводится к диaпазону [50..100].</p>
        <button class="btn" data-action="toHideTheory">Закрыть</button>
      </div>
    </section>
  </main>
  <script src="js/ace.js"></script>
  <script src="js/html2canvas.js"></script>
  <script src="js/resemble.js"></script>
  <script src="js/index.js"></script>
</body>
</html>
